// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Service.proto

#ifndef PROTOBUF_Service_2eproto__INCLUDED
#define PROTOBUF_Service_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Error.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_Service_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsGetServiceReqImpl();
void InitDefaultsGetServiceReq();
void InitDefaultsServiceImpl();
void InitDefaultsService();
void InitDefaultsGetServiceAddressReqImpl();
void InitDefaultsGetServiceAddressReq();
void InitDefaultsGetServiceAddressRspImpl();
void InitDefaultsGetServiceAddressRsp();
void InitDefaultsSubServiceAddressReqImpl();
void InitDefaultsSubServiceAddressReq();
void InitDefaultsSubServiceAddressRspImpl();
void InitDefaultsSubServiceAddressRsp();
void InitDefaultsPubServiceAddressReqImpl();
void InitDefaultsPubServiceAddressReq();
void InitDefaultsPubServiceAddressRspImpl();
void InitDefaultsPubServiceAddressRsp();
void InitDefaultsOnPubServiceAddressImpl();
void InitDefaultsOnPubServiceAddress();
inline void InitDefaults() {
  InitDefaultsGetServiceReq();
  InitDefaultsService();
  InitDefaultsGetServiceAddressReq();
  InitDefaultsGetServiceAddressRsp();
  InitDefaultsSubServiceAddressReq();
  InitDefaultsSubServiceAddressRsp();
  InitDefaultsPubServiceAddressReq();
  InitDefaultsPubServiceAddressRsp();
  InitDefaultsOnPubServiceAddress();
}
}  // namespace protobuf_Service_2eproto
namespace eco {
namespace service {
namespace proto {
class GetServiceAddressReq;
class GetServiceAddressReqDefaultTypeInternal;
extern GetServiceAddressReqDefaultTypeInternal _GetServiceAddressReq_default_instance_;
class GetServiceAddressRsp;
class GetServiceAddressRspDefaultTypeInternal;
extern GetServiceAddressRspDefaultTypeInternal _GetServiceAddressRsp_default_instance_;
class GetServiceReq;
class GetServiceReqDefaultTypeInternal;
extern GetServiceReqDefaultTypeInternal _GetServiceReq_default_instance_;
class OnPubServiceAddress;
class OnPubServiceAddressDefaultTypeInternal;
extern OnPubServiceAddressDefaultTypeInternal _OnPubServiceAddress_default_instance_;
class PubServiceAddressReq;
class PubServiceAddressReqDefaultTypeInternal;
extern PubServiceAddressReqDefaultTypeInternal _PubServiceAddressReq_default_instance_;
class PubServiceAddressRsp;
class PubServiceAddressRspDefaultTypeInternal;
extern PubServiceAddressRspDefaultTypeInternal _PubServiceAddressRsp_default_instance_;
class Service;
class ServiceDefaultTypeInternal;
extern ServiceDefaultTypeInternal _Service_default_instance_;
class SubServiceAddressReq;
class SubServiceAddressReqDefaultTypeInternal;
extern SubServiceAddressReqDefaultTypeInternal _SubServiceAddressReq_default_instance_;
class SubServiceAddressRsp;
class SubServiceAddressRspDefaultTypeInternal;
extern SubServiceAddressRspDefaultTypeInternal _SubServiceAddressRsp_default_instance_;
}  // namespace proto
}  // namespace service
}  // namespace eco
namespace eco {
namespace service {
namespace proto {

// ===================================================================

class GetServiceReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eco.service.proto.GetServiceReq) */ {
 public:
  GetServiceReq();
  virtual ~GetServiceReq();

  GetServiceReq(const GetServiceReq& from);

  inline GetServiceReq& operator=(const GetServiceReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetServiceReq(GetServiceReq&& from) noexcept
    : GetServiceReq() {
    *this = ::std::move(from);
  }

  inline GetServiceReq& operator=(GetServiceReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetServiceReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetServiceReq* internal_default_instance() {
    return reinterpret_cast<const GetServiceReq*>(
               &_GetServiceReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(GetServiceReq* other);
  friend void swap(GetServiceReq& a, GetServiceReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetServiceReq* New() const PROTOBUF_FINAL { return New(NULL); }

  GetServiceReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetServiceReq& from);
  void MergeFrom(const GetServiceReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetServiceReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string service_name = 10;
  void clear_service_name();
  static const int kServiceNameFieldNumber = 10;
  const ::std::string& service_name() const;
  void set_service_name(const ::std::string& value);
  #if LANG_CXX11
  void set_service_name(::std::string&& value);
  #endif
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  ::std::string* mutable_service_name();
  ::std::string* release_service_name();
  void set_allocated_service_name(::std::string* service_name);

  // @@protoc_insertion_point(class_scope:eco.service.proto.GetServiceReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr service_name_;
  mutable int _cached_size_;
  friend struct ::protobuf_Service_2eproto::TableStruct;
  friend void ::protobuf_Service_2eproto::InitDefaultsGetServiceReqImpl();
};
// -------------------------------------------------------------------

class Service : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eco.service.proto.Service) */ {
 public:
  Service();
  virtual ~Service();

  Service(const Service& from);

  inline Service& operator=(const Service& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Service(Service&& from) noexcept
    : Service() {
    *this = ::std::move(from);
  }

  inline Service& operator=(Service&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Service& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Service* internal_default_instance() {
    return reinterpret_cast<const Service*>(
               &_Service_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Service* other);
  friend void swap(Service& a, Service& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Service* New() const PROTOBUF_FINAL { return New(NULL); }

  Service* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Service& from);
  void MergeFrom(const Service& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Service* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string service_name = 10;
  void clear_service_name();
  static const int kServiceNameFieldNumber = 10;
  const ::std::string& service_name() const;
  void set_service_name(const ::std::string& value);
  #if LANG_CXX11
  void set_service_name(::std::string&& value);
  #endif
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  ::std::string* mutable_service_name();
  ::std::string* release_service_name();
  void set_allocated_service_name(::std::string* service_name);

  // string process_name = 11;
  void clear_process_name();
  static const int kProcessNameFieldNumber = 11;
  const ::std::string& process_name() const;
  void set_process_name(const ::std::string& value);
  #if LANG_CXX11
  void set_process_name(::std::string&& value);
  #endif
  void set_process_name(const char* value);
  void set_process_name(const char* value, size_t size);
  ::std::string* mutable_process_name();
  ::std::string* release_process_name();
  void set_allocated_process_name(::std::string* process_name);

  // string did_protocol = 12;
  void clear_did_protocol();
  static const int kDidProtocolFieldNumber = 12;
  const ::std::string& did_protocol() const;
  void set_did_protocol(const ::std::string& value);
  #if LANG_CXX11
  void set_did_protocol(::std::string&& value);
  #endif
  void set_did_protocol(const char* value);
  void set_did_protocol(const char* value, size_t size);
  ::std::string* mutable_did_protocol();
  ::std::string* release_did_protocol();
  void set_allocated_did_protocol(::std::string* did_protocol);

  // string object_name = 13;
  void clear_object_name();
  static const int kObjectNameFieldNumber = 13;
  const ::std::string& object_name() const;
  void set_object_name(const ::std::string& value);
  #if LANG_CXX11
  void set_object_name(::std::string&& value);
  #endif
  void set_object_name(const char* value);
  void set_object_name(const char* value, size_t size);
  ::std::string* mutable_object_name();
  ::std::string* release_object_name();
  void set_allocated_object_name(::std::string* object_name);

  // .eco.service.proto.Error error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::eco::service::proto::Error& error() const;
  ::eco::service::proto::Error* release_error();
  ::eco::service::proto::Error* mutable_error();
  void set_allocated_error(::eco::service::proto::Error* error);

  // int64 max_future_object_workload = 14;
  void clear_max_future_object_workload();
  static const int kMaxFutureObjectWorkloadFieldNumber = 14;
  ::google::protobuf::int64 max_future_object_workload() const;
  void set_max_future_object_workload(::google::protobuf::int64 value);

  // int64 max_limited_object_workload = 15;
  void clear_max_limited_object_workload();
  static const int kMaxLimitedObjectWorkloadFieldNumber = 15;
  ::google::protobuf::int64 max_limited_object_workload() const;
  void set_max_limited_object_workload(::google::protobuf::int64 value);

  // int32 virtual_service_object_workload = 16;
  void clear_virtual_service_object_workload();
  static const int kVirtualServiceObjectWorkloadFieldNumber = 16;
  ::google::protobuf::int32 virtual_service_object_workload() const;
  void set_virtual_service_object_workload(::google::protobuf::int32 value);

  // int32 horizontal_virtual_service_number = 17;
  void clear_horizontal_virtual_service_number();
  static const int kHorizontalVirtualServiceNumberFieldNumber = 17;
  ::google::protobuf::int32 horizontal_virtual_service_number() const;
  void set_horizontal_virtual_service_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:eco.service.proto.Service)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr service_name_;
  ::google::protobuf::internal::ArenaStringPtr process_name_;
  ::google::protobuf::internal::ArenaStringPtr did_protocol_;
  ::google::protobuf::internal::ArenaStringPtr object_name_;
  ::eco::service::proto::Error* error_;
  ::google::protobuf::int64 max_future_object_workload_;
  ::google::protobuf::int64 max_limited_object_workload_;
  ::google::protobuf::int32 virtual_service_object_workload_;
  ::google::protobuf::int32 horizontal_virtual_service_number_;
  mutable int _cached_size_;
  friend struct ::protobuf_Service_2eproto::TableStruct;
  friend void ::protobuf_Service_2eproto::InitDefaultsServiceImpl();
};
// -------------------------------------------------------------------

class GetServiceAddressReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eco.service.proto.GetServiceAddressReq) */ {
 public:
  GetServiceAddressReq();
  virtual ~GetServiceAddressReq();

  GetServiceAddressReq(const GetServiceAddressReq& from);

  inline GetServiceAddressReq& operator=(const GetServiceAddressReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetServiceAddressReq(GetServiceAddressReq&& from) noexcept
    : GetServiceAddressReq() {
    *this = ::std::move(from);
  }

  inline GetServiceAddressReq& operator=(GetServiceAddressReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetServiceAddressReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetServiceAddressReq* internal_default_instance() {
    return reinterpret_cast<const GetServiceAddressReq*>(
               &_GetServiceAddressReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(GetServiceAddressReq* other);
  friend void swap(GetServiceAddressReq& a, GetServiceAddressReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetServiceAddressReq* New() const PROTOBUF_FINAL { return New(NULL); }

  GetServiceAddressReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetServiceAddressReq& from);
  void MergeFrom(const GetServiceAddressReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetServiceAddressReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string service_name = 10;
  void clear_service_name();
  static const int kServiceNameFieldNumber = 10;
  const ::std::string& service_name() const;
  void set_service_name(const ::std::string& value);
  #if LANG_CXX11
  void set_service_name(::std::string&& value);
  #endif
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  ::std::string* mutable_service_name();
  ::std::string* release_service_name();
  void set_allocated_service_name(::std::string* service_name);

  // @@protoc_insertion_point(class_scope:eco.service.proto.GetServiceAddressReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr service_name_;
  mutable int _cached_size_;
  friend struct ::protobuf_Service_2eproto::TableStruct;
  friend void ::protobuf_Service_2eproto::InitDefaultsGetServiceAddressReqImpl();
};
// -------------------------------------------------------------------

class GetServiceAddressRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eco.service.proto.GetServiceAddressRsp) */ {
 public:
  GetServiceAddressRsp();
  virtual ~GetServiceAddressRsp();

  GetServiceAddressRsp(const GetServiceAddressRsp& from);

  inline GetServiceAddressRsp& operator=(const GetServiceAddressRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetServiceAddressRsp(GetServiceAddressRsp&& from) noexcept
    : GetServiceAddressRsp() {
    *this = ::std::move(from);
  }

  inline GetServiceAddressRsp& operator=(GetServiceAddressRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetServiceAddressRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetServiceAddressRsp* internal_default_instance() {
    return reinterpret_cast<const GetServiceAddressRsp*>(
               &_GetServiceAddressRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(GetServiceAddressRsp* other);
  friend void swap(GetServiceAddressRsp& a, GetServiceAddressRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetServiceAddressRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  GetServiceAddressRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetServiceAddressRsp& from);
  void MergeFrom(const GetServiceAddressRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetServiceAddressRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string service_name = 10;
  void clear_service_name();
  static const int kServiceNameFieldNumber = 10;
  const ::std::string& service_name() const;
  void set_service_name(const ::std::string& value);
  #if LANG_CXX11
  void set_service_name(::std::string&& value);
  #endif
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  ::std::string* mutable_service_name();
  ::std::string* release_service_name();
  void set_allocated_service_name(::std::string* service_name);

  // .eco.service.proto.Error error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::eco::service::proto::Error& error() const;
  ::eco::service::proto::Error* release_error();
  ::eco::service::proto::Error* mutable_error();
  void set_allocated_error(::eco::service::proto::Error* error);

  // @@protoc_insertion_point(class_scope:eco.service.proto.GetServiceAddressRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr service_name_;
  ::eco::service::proto::Error* error_;
  mutable int _cached_size_;
  friend struct ::protobuf_Service_2eproto::TableStruct;
  friend void ::protobuf_Service_2eproto::InitDefaultsGetServiceAddressRspImpl();
};
// -------------------------------------------------------------------

class SubServiceAddressReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eco.service.proto.SubServiceAddressReq) */ {
 public:
  SubServiceAddressReq();
  virtual ~SubServiceAddressReq();

  SubServiceAddressReq(const SubServiceAddressReq& from);

  inline SubServiceAddressReq& operator=(const SubServiceAddressReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubServiceAddressReq(SubServiceAddressReq&& from) noexcept
    : SubServiceAddressReq() {
    *this = ::std::move(from);
  }

  inline SubServiceAddressReq& operator=(SubServiceAddressReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SubServiceAddressReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubServiceAddressReq* internal_default_instance() {
    return reinterpret_cast<const SubServiceAddressReq*>(
               &_SubServiceAddressReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(SubServiceAddressReq* other);
  friend void swap(SubServiceAddressReq& a, SubServiceAddressReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubServiceAddressReq* New() const PROTOBUF_FINAL { return New(NULL); }

  SubServiceAddressReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SubServiceAddressReq& from);
  void MergeFrom(const SubServiceAddressReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SubServiceAddressReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string service_name = 10;
  void clear_service_name();
  static const int kServiceNameFieldNumber = 10;
  const ::std::string& service_name() const;
  void set_service_name(const ::std::string& value);
  #if LANG_CXX11
  void set_service_name(::std::string&& value);
  #endif
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  ::std::string* mutable_service_name();
  ::std::string* release_service_name();
  void set_allocated_service_name(::std::string* service_name);

  // @@protoc_insertion_point(class_scope:eco.service.proto.SubServiceAddressReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr service_name_;
  mutable int _cached_size_;
  friend struct ::protobuf_Service_2eproto::TableStruct;
  friend void ::protobuf_Service_2eproto::InitDefaultsSubServiceAddressReqImpl();
};
// -------------------------------------------------------------------

class SubServiceAddressRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eco.service.proto.SubServiceAddressRsp) */ {
 public:
  SubServiceAddressRsp();
  virtual ~SubServiceAddressRsp();

  SubServiceAddressRsp(const SubServiceAddressRsp& from);

  inline SubServiceAddressRsp& operator=(const SubServiceAddressRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubServiceAddressRsp(SubServiceAddressRsp&& from) noexcept
    : SubServiceAddressRsp() {
    *this = ::std::move(from);
  }

  inline SubServiceAddressRsp& operator=(SubServiceAddressRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SubServiceAddressRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubServiceAddressRsp* internal_default_instance() {
    return reinterpret_cast<const SubServiceAddressRsp*>(
               &_SubServiceAddressRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(SubServiceAddressRsp* other);
  friend void swap(SubServiceAddressRsp& a, SubServiceAddressRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubServiceAddressRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  SubServiceAddressRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SubServiceAddressRsp& from);
  void MergeFrom(const SubServiceAddressRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SubServiceAddressRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string service_name = 10;
  void clear_service_name();
  static const int kServiceNameFieldNumber = 10;
  const ::std::string& service_name() const;
  void set_service_name(const ::std::string& value);
  #if LANG_CXX11
  void set_service_name(::std::string&& value);
  #endif
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  ::std::string* mutable_service_name();
  ::std::string* release_service_name();
  void set_allocated_service_name(::std::string* service_name);

  // .eco.service.proto.Error error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::eco::service::proto::Error& error() const;
  ::eco::service::proto::Error* release_error();
  ::eco::service::proto::Error* mutable_error();
  void set_allocated_error(::eco::service::proto::Error* error);

  // @@protoc_insertion_point(class_scope:eco.service.proto.SubServiceAddressRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr service_name_;
  ::eco::service::proto::Error* error_;
  mutable int _cached_size_;
  friend struct ::protobuf_Service_2eproto::TableStruct;
  friend void ::protobuf_Service_2eproto::InitDefaultsSubServiceAddressRspImpl();
};
// -------------------------------------------------------------------

class PubServiceAddressReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eco.service.proto.PubServiceAddressReq) */ {
 public:
  PubServiceAddressReq();
  virtual ~PubServiceAddressReq();

  PubServiceAddressReq(const PubServiceAddressReq& from);

  inline PubServiceAddressReq& operator=(const PubServiceAddressReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PubServiceAddressReq(PubServiceAddressReq&& from) noexcept
    : PubServiceAddressReq() {
    *this = ::std::move(from);
  }

  inline PubServiceAddressReq& operator=(PubServiceAddressReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PubServiceAddressReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PubServiceAddressReq* internal_default_instance() {
    return reinterpret_cast<const PubServiceAddressReq*>(
               &_PubServiceAddressReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(PubServiceAddressReq* other);
  friend void swap(PubServiceAddressReq& a, PubServiceAddressReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PubServiceAddressReq* New() const PROTOBUF_FINAL { return New(NULL); }

  PubServiceAddressReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PubServiceAddressReq& from);
  void MergeFrom(const PubServiceAddressReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PubServiceAddressReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string service_name = 10;
  void clear_service_name();
  static const int kServiceNameFieldNumber = 10;
  const ::std::string& service_name() const;
  void set_service_name(const ::std::string& value);
  #if LANG_CXX11
  void set_service_name(::std::string&& value);
  #endif
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  ::std::string* mutable_service_name();
  ::std::string* release_service_name();
  void set_allocated_service_name(::std::string* service_name);

  // @@protoc_insertion_point(class_scope:eco.service.proto.PubServiceAddressReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr service_name_;
  mutable int _cached_size_;
  friend struct ::protobuf_Service_2eproto::TableStruct;
  friend void ::protobuf_Service_2eproto::InitDefaultsPubServiceAddressReqImpl();
};
// -------------------------------------------------------------------

class PubServiceAddressRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eco.service.proto.PubServiceAddressRsp) */ {
 public:
  PubServiceAddressRsp();
  virtual ~PubServiceAddressRsp();

  PubServiceAddressRsp(const PubServiceAddressRsp& from);

  inline PubServiceAddressRsp& operator=(const PubServiceAddressRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PubServiceAddressRsp(PubServiceAddressRsp&& from) noexcept
    : PubServiceAddressRsp() {
    *this = ::std::move(from);
  }

  inline PubServiceAddressRsp& operator=(PubServiceAddressRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PubServiceAddressRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PubServiceAddressRsp* internal_default_instance() {
    return reinterpret_cast<const PubServiceAddressRsp*>(
               &_PubServiceAddressRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(PubServiceAddressRsp* other);
  friend void swap(PubServiceAddressRsp& a, PubServiceAddressRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PubServiceAddressRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  PubServiceAddressRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PubServiceAddressRsp& from);
  void MergeFrom(const PubServiceAddressRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PubServiceAddressRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string service_name = 10;
  void clear_service_name();
  static const int kServiceNameFieldNumber = 10;
  const ::std::string& service_name() const;
  void set_service_name(const ::std::string& value);
  #if LANG_CXX11
  void set_service_name(::std::string&& value);
  #endif
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  ::std::string* mutable_service_name();
  ::std::string* release_service_name();
  void set_allocated_service_name(::std::string* service_name);

  // .eco.service.proto.Error error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::eco::service::proto::Error& error() const;
  ::eco::service::proto::Error* release_error();
  ::eco::service::proto::Error* mutable_error();
  void set_allocated_error(::eco::service::proto::Error* error);

  // @@protoc_insertion_point(class_scope:eco.service.proto.PubServiceAddressRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr service_name_;
  ::eco::service::proto::Error* error_;
  mutable int _cached_size_;
  friend struct ::protobuf_Service_2eproto::TableStruct;
  friend void ::protobuf_Service_2eproto::InitDefaultsPubServiceAddressRspImpl();
};
// -------------------------------------------------------------------

class OnPubServiceAddress : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eco.service.proto.OnPubServiceAddress) */ {
 public:
  OnPubServiceAddress();
  virtual ~OnPubServiceAddress();

  OnPubServiceAddress(const OnPubServiceAddress& from);

  inline OnPubServiceAddress& operator=(const OnPubServiceAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OnPubServiceAddress(OnPubServiceAddress&& from) noexcept
    : OnPubServiceAddress() {
    *this = ::std::move(from);
  }

  inline OnPubServiceAddress& operator=(OnPubServiceAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OnPubServiceAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OnPubServiceAddress* internal_default_instance() {
    return reinterpret_cast<const OnPubServiceAddress*>(
               &_OnPubServiceAddress_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(OnPubServiceAddress* other);
  friend void swap(OnPubServiceAddress& a, OnPubServiceAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OnPubServiceAddress* New() const PROTOBUF_FINAL { return New(NULL); }

  OnPubServiceAddress* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OnPubServiceAddress& from);
  void MergeFrom(const OnPubServiceAddress& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OnPubServiceAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string service_name = 10;
  void clear_service_name();
  static const int kServiceNameFieldNumber = 10;
  const ::std::string& service_name() const;
  void set_service_name(const ::std::string& value);
  #if LANG_CXX11
  void set_service_name(::std::string&& value);
  #endif
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  ::std::string* mutable_service_name();
  ::std::string* release_service_name();
  void set_allocated_service_name(::std::string* service_name);

  // @@protoc_insertion_point(class_scope:eco.service.proto.OnPubServiceAddress)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr service_name_;
  mutable int _cached_size_;
  friend struct ::protobuf_Service_2eproto::TableStruct;
  friend void ::protobuf_Service_2eproto::InitDefaultsOnPubServiceAddressImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetServiceReq

// string service_name = 10;
inline void GetServiceReq::clear_service_name() {
  service_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetServiceReq::service_name() const {
  // @@protoc_insertion_point(field_get:eco.service.proto.GetServiceReq.service_name)
  return service_name_.GetNoArena();
}
inline void GetServiceReq::set_service_name(const ::std::string& value) {
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eco.service.proto.GetServiceReq.service_name)
}
#if LANG_CXX11
inline void GetServiceReq::set_service_name(::std::string&& value) {
  
  service_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eco.service.proto.GetServiceReq.service_name)
}
#endif
inline void GetServiceReq::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eco.service.proto.GetServiceReq.service_name)
}
inline void GetServiceReq::set_service_name(const char* value, size_t size) {
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eco.service.proto.GetServiceReq.service_name)
}
inline ::std::string* GetServiceReq::mutable_service_name() {
  
  // @@protoc_insertion_point(field_mutable:eco.service.proto.GetServiceReq.service_name)
  return service_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetServiceReq::release_service_name() {
  // @@protoc_insertion_point(field_release:eco.service.proto.GetServiceReq.service_name)
  
  return service_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetServiceReq::set_allocated_service_name(::std::string* service_name) {
  if (service_name != NULL) {
    
  } else {
    
  }
  service_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service_name);
  // @@protoc_insertion_point(field_set_allocated:eco.service.proto.GetServiceReq.service_name)
}

// -------------------------------------------------------------------

// Service

// .eco.service.proto.Error error = 2;
inline bool Service::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline const ::eco::service::proto::Error& Service::error() const {
  const ::eco::service::proto::Error* p = error_;
  // @@protoc_insertion_point(field_get:eco.service.proto.Service.error)
  return p != NULL ? *p : *reinterpret_cast<const ::eco::service::proto::Error*>(
      &::eco::service::proto::_Error_default_instance_);
}
inline ::eco::service::proto::Error* Service::release_error() {
  // @@protoc_insertion_point(field_release:eco.service.proto.Service.error)
  
  ::eco::service::proto::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::eco::service::proto::Error* Service::mutable_error() {
  
  if (error_ == NULL) {
    error_ = new ::eco::service::proto::Error;
  }
  // @@protoc_insertion_point(field_mutable:eco.service.proto.Service.error)
  return error_;
}
inline void Service::set_allocated_error(::eco::service::proto::Error* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:eco.service.proto.Service.error)
}

// string service_name = 10;
inline void Service::clear_service_name() {
  service_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Service::service_name() const {
  // @@protoc_insertion_point(field_get:eco.service.proto.Service.service_name)
  return service_name_.GetNoArena();
}
inline void Service::set_service_name(const ::std::string& value) {
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eco.service.proto.Service.service_name)
}
#if LANG_CXX11
inline void Service::set_service_name(::std::string&& value) {
  
  service_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eco.service.proto.Service.service_name)
}
#endif
inline void Service::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eco.service.proto.Service.service_name)
}
inline void Service::set_service_name(const char* value, size_t size) {
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eco.service.proto.Service.service_name)
}
inline ::std::string* Service::mutable_service_name() {
  
  // @@protoc_insertion_point(field_mutable:eco.service.proto.Service.service_name)
  return service_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Service::release_service_name() {
  // @@protoc_insertion_point(field_release:eco.service.proto.Service.service_name)
  
  return service_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Service::set_allocated_service_name(::std::string* service_name) {
  if (service_name != NULL) {
    
  } else {
    
  }
  service_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service_name);
  // @@protoc_insertion_point(field_set_allocated:eco.service.proto.Service.service_name)
}

// string process_name = 11;
inline void Service::clear_process_name() {
  process_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Service::process_name() const {
  // @@protoc_insertion_point(field_get:eco.service.proto.Service.process_name)
  return process_name_.GetNoArena();
}
inline void Service::set_process_name(const ::std::string& value) {
  
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eco.service.proto.Service.process_name)
}
#if LANG_CXX11
inline void Service::set_process_name(::std::string&& value) {
  
  process_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eco.service.proto.Service.process_name)
}
#endif
inline void Service::set_process_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eco.service.proto.Service.process_name)
}
inline void Service::set_process_name(const char* value, size_t size) {
  
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eco.service.proto.Service.process_name)
}
inline ::std::string* Service::mutable_process_name() {
  
  // @@protoc_insertion_point(field_mutable:eco.service.proto.Service.process_name)
  return process_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Service::release_process_name() {
  // @@protoc_insertion_point(field_release:eco.service.proto.Service.process_name)
  
  return process_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Service::set_allocated_process_name(::std::string* process_name) {
  if (process_name != NULL) {
    
  } else {
    
  }
  process_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), process_name);
  // @@protoc_insertion_point(field_set_allocated:eco.service.proto.Service.process_name)
}

// string did_protocol = 12;
inline void Service::clear_did_protocol() {
  did_protocol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Service::did_protocol() const {
  // @@protoc_insertion_point(field_get:eco.service.proto.Service.did_protocol)
  return did_protocol_.GetNoArena();
}
inline void Service::set_did_protocol(const ::std::string& value) {
  
  did_protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eco.service.proto.Service.did_protocol)
}
#if LANG_CXX11
inline void Service::set_did_protocol(::std::string&& value) {
  
  did_protocol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eco.service.proto.Service.did_protocol)
}
#endif
inline void Service::set_did_protocol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  did_protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eco.service.proto.Service.did_protocol)
}
inline void Service::set_did_protocol(const char* value, size_t size) {
  
  did_protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eco.service.proto.Service.did_protocol)
}
inline ::std::string* Service::mutable_did_protocol() {
  
  // @@protoc_insertion_point(field_mutable:eco.service.proto.Service.did_protocol)
  return did_protocol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Service::release_did_protocol() {
  // @@protoc_insertion_point(field_release:eco.service.proto.Service.did_protocol)
  
  return did_protocol_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Service::set_allocated_did_protocol(::std::string* did_protocol) {
  if (did_protocol != NULL) {
    
  } else {
    
  }
  did_protocol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), did_protocol);
  // @@protoc_insertion_point(field_set_allocated:eco.service.proto.Service.did_protocol)
}

// string object_name = 13;
inline void Service::clear_object_name() {
  object_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Service::object_name() const {
  // @@protoc_insertion_point(field_get:eco.service.proto.Service.object_name)
  return object_name_.GetNoArena();
}
inline void Service::set_object_name(const ::std::string& value) {
  
  object_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eco.service.proto.Service.object_name)
}
#if LANG_CXX11
inline void Service::set_object_name(::std::string&& value) {
  
  object_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eco.service.proto.Service.object_name)
}
#endif
inline void Service::set_object_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  object_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eco.service.proto.Service.object_name)
}
inline void Service::set_object_name(const char* value, size_t size) {
  
  object_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eco.service.proto.Service.object_name)
}
inline ::std::string* Service::mutable_object_name() {
  
  // @@protoc_insertion_point(field_mutable:eco.service.proto.Service.object_name)
  return object_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Service::release_object_name() {
  // @@protoc_insertion_point(field_release:eco.service.proto.Service.object_name)
  
  return object_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Service::set_allocated_object_name(::std::string* object_name) {
  if (object_name != NULL) {
    
  } else {
    
  }
  object_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), object_name);
  // @@protoc_insertion_point(field_set_allocated:eco.service.proto.Service.object_name)
}

// int64 max_future_object_workload = 14;
inline void Service::clear_max_future_object_workload() {
  max_future_object_workload_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Service::max_future_object_workload() const {
  // @@protoc_insertion_point(field_get:eco.service.proto.Service.max_future_object_workload)
  return max_future_object_workload_;
}
inline void Service::set_max_future_object_workload(::google::protobuf::int64 value) {
  
  max_future_object_workload_ = value;
  // @@protoc_insertion_point(field_set:eco.service.proto.Service.max_future_object_workload)
}

// int64 max_limited_object_workload = 15;
inline void Service::clear_max_limited_object_workload() {
  max_limited_object_workload_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Service::max_limited_object_workload() const {
  // @@protoc_insertion_point(field_get:eco.service.proto.Service.max_limited_object_workload)
  return max_limited_object_workload_;
}
inline void Service::set_max_limited_object_workload(::google::protobuf::int64 value) {
  
  max_limited_object_workload_ = value;
  // @@protoc_insertion_point(field_set:eco.service.proto.Service.max_limited_object_workload)
}

// int32 virtual_service_object_workload = 16;
inline void Service::clear_virtual_service_object_workload() {
  virtual_service_object_workload_ = 0;
}
inline ::google::protobuf::int32 Service::virtual_service_object_workload() const {
  // @@protoc_insertion_point(field_get:eco.service.proto.Service.virtual_service_object_workload)
  return virtual_service_object_workload_;
}
inline void Service::set_virtual_service_object_workload(::google::protobuf::int32 value) {
  
  virtual_service_object_workload_ = value;
  // @@protoc_insertion_point(field_set:eco.service.proto.Service.virtual_service_object_workload)
}

// int32 horizontal_virtual_service_number = 17;
inline void Service::clear_horizontal_virtual_service_number() {
  horizontal_virtual_service_number_ = 0;
}
inline ::google::protobuf::int32 Service::horizontal_virtual_service_number() const {
  // @@protoc_insertion_point(field_get:eco.service.proto.Service.horizontal_virtual_service_number)
  return horizontal_virtual_service_number_;
}
inline void Service::set_horizontal_virtual_service_number(::google::protobuf::int32 value) {
  
  horizontal_virtual_service_number_ = value;
  // @@protoc_insertion_point(field_set:eco.service.proto.Service.horizontal_virtual_service_number)
}

// -------------------------------------------------------------------

// GetServiceAddressReq

// string service_name = 10;
inline void GetServiceAddressReq::clear_service_name() {
  service_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetServiceAddressReq::service_name() const {
  // @@protoc_insertion_point(field_get:eco.service.proto.GetServiceAddressReq.service_name)
  return service_name_.GetNoArena();
}
inline void GetServiceAddressReq::set_service_name(const ::std::string& value) {
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eco.service.proto.GetServiceAddressReq.service_name)
}
#if LANG_CXX11
inline void GetServiceAddressReq::set_service_name(::std::string&& value) {
  
  service_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eco.service.proto.GetServiceAddressReq.service_name)
}
#endif
inline void GetServiceAddressReq::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eco.service.proto.GetServiceAddressReq.service_name)
}
inline void GetServiceAddressReq::set_service_name(const char* value, size_t size) {
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eco.service.proto.GetServiceAddressReq.service_name)
}
inline ::std::string* GetServiceAddressReq::mutable_service_name() {
  
  // @@protoc_insertion_point(field_mutable:eco.service.proto.GetServiceAddressReq.service_name)
  return service_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetServiceAddressReq::release_service_name() {
  // @@protoc_insertion_point(field_release:eco.service.proto.GetServiceAddressReq.service_name)
  
  return service_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetServiceAddressReq::set_allocated_service_name(::std::string* service_name) {
  if (service_name != NULL) {
    
  } else {
    
  }
  service_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service_name);
  // @@protoc_insertion_point(field_set_allocated:eco.service.proto.GetServiceAddressReq.service_name)
}

// -------------------------------------------------------------------

// GetServiceAddressRsp

// .eco.service.proto.Error error = 2;
inline bool GetServiceAddressRsp::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline const ::eco::service::proto::Error& GetServiceAddressRsp::error() const {
  const ::eco::service::proto::Error* p = error_;
  // @@protoc_insertion_point(field_get:eco.service.proto.GetServiceAddressRsp.error)
  return p != NULL ? *p : *reinterpret_cast<const ::eco::service::proto::Error*>(
      &::eco::service::proto::_Error_default_instance_);
}
inline ::eco::service::proto::Error* GetServiceAddressRsp::release_error() {
  // @@protoc_insertion_point(field_release:eco.service.proto.GetServiceAddressRsp.error)
  
  ::eco::service::proto::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::eco::service::proto::Error* GetServiceAddressRsp::mutable_error() {
  
  if (error_ == NULL) {
    error_ = new ::eco::service::proto::Error;
  }
  // @@protoc_insertion_point(field_mutable:eco.service.proto.GetServiceAddressRsp.error)
  return error_;
}
inline void GetServiceAddressRsp::set_allocated_error(::eco::service::proto::Error* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:eco.service.proto.GetServiceAddressRsp.error)
}

// string service_name = 10;
inline void GetServiceAddressRsp::clear_service_name() {
  service_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetServiceAddressRsp::service_name() const {
  // @@protoc_insertion_point(field_get:eco.service.proto.GetServiceAddressRsp.service_name)
  return service_name_.GetNoArena();
}
inline void GetServiceAddressRsp::set_service_name(const ::std::string& value) {
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eco.service.proto.GetServiceAddressRsp.service_name)
}
#if LANG_CXX11
inline void GetServiceAddressRsp::set_service_name(::std::string&& value) {
  
  service_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eco.service.proto.GetServiceAddressRsp.service_name)
}
#endif
inline void GetServiceAddressRsp::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eco.service.proto.GetServiceAddressRsp.service_name)
}
inline void GetServiceAddressRsp::set_service_name(const char* value, size_t size) {
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eco.service.proto.GetServiceAddressRsp.service_name)
}
inline ::std::string* GetServiceAddressRsp::mutable_service_name() {
  
  // @@protoc_insertion_point(field_mutable:eco.service.proto.GetServiceAddressRsp.service_name)
  return service_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetServiceAddressRsp::release_service_name() {
  // @@protoc_insertion_point(field_release:eco.service.proto.GetServiceAddressRsp.service_name)
  
  return service_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetServiceAddressRsp::set_allocated_service_name(::std::string* service_name) {
  if (service_name != NULL) {
    
  } else {
    
  }
  service_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service_name);
  // @@protoc_insertion_point(field_set_allocated:eco.service.proto.GetServiceAddressRsp.service_name)
}

// -------------------------------------------------------------------

// SubServiceAddressReq

// string service_name = 10;
inline void SubServiceAddressReq::clear_service_name() {
  service_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SubServiceAddressReq::service_name() const {
  // @@protoc_insertion_point(field_get:eco.service.proto.SubServiceAddressReq.service_name)
  return service_name_.GetNoArena();
}
inline void SubServiceAddressReq::set_service_name(const ::std::string& value) {
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eco.service.proto.SubServiceAddressReq.service_name)
}
#if LANG_CXX11
inline void SubServiceAddressReq::set_service_name(::std::string&& value) {
  
  service_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eco.service.proto.SubServiceAddressReq.service_name)
}
#endif
inline void SubServiceAddressReq::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eco.service.proto.SubServiceAddressReq.service_name)
}
inline void SubServiceAddressReq::set_service_name(const char* value, size_t size) {
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eco.service.proto.SubServiceAddressReq.service_name)
}
inline ::std::string* SubServiceAddressReq::mutable_service_name() {
  
  // @@protoc_insertion_point(field_mutable:eco.service.proto.SubServiceAddressReq.service_name)
  return service_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubServiceAddressReq::release_service_name() {
  // @@protoc_insertion_point(field_release:eco.service.proto.SubServiceAddressReq.service_name)
  
  return service_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubServiceAddressReq::set_allocated_service_name(::std::string* service_name) {
  if (service_name != NULL) {
    
  } else {
    
  }
  service_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service_name);
  // @@protoc_insertion_point(field_set_allocated:eco.service.proto.SubServiceAddressReq.service_name)
}

// -------------------------------------------------------------------

// SubServiceAddressRsp

// .eco.service.proto.Error error = 2;
inline bool SubServiceAddressRsp::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline const ::eco::service::proto::Error& SubServiceAddressRsp::error() const {
  const ::eco::service::proto::Error* p = error_;
  // @@protoc_insertion_point(field_get:eco.service.proto.SubServiceAddressRsp.error)
  return p != NULL ? *p : *reinterpret_cast<const ::eco::service::proto::Error*>(
      &::eco::service::proto::_Error_default_instance_);
}
inline ::eco::service::proto::Error* SubServiceAddressRsp::release_error() {
  // @@protoc_insertion_point(field_release:eco.service.proto.SubServiceAddressRsp.error)
  
  ::eco::service::proto::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::eco::service::proto::Error* SubServiceAddressRsp::mutable_error() {
  
  if (error_ == NULL) {
    error_ = new ::eco::service::proto::Error;
  }
  // @@protoc_insertion_point(field_mutable:eco.service.proto.SubServiceAddressRsp.error)
  return error_;
}
inline void SubServiceAddressRsp::set_allocated_error(::eco::service::proto::Error* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:eco.service.proto.SubServiceAddressRsp.error)
}

// string service_name = 10;
inline void SubServiceAddressRsp::clear_service_name() {
  service_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SubServiceAddressRsp::service_name() const {
  // @@protoc_insertion_point(field_get:eco.service.proto.SubServiceAddressRsp.service_name)
  return service_name_.GetNoArena();
}
inline void SubServiceAddressRsp::set_service_name(const ::std::string& value) {
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eco.service.proto.SubServiceAddressRsp.service_name)
}
#if LANG_CXX11
inline void SubServiceAddressRsp::set_service_name(::std::string&& value) {
  
  service_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eco.service.proto.SubServiceAddressRsp.service_name)
}
#endif
inline void SubServiceAddressRsp::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eco.service.proto.SubServiceAddressRsp.service_name)
}
inline void SubServiceAddressRsp::set_service_name(const char* value, size_t size) {
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eco.service.proto.SubServiceAddressRsp.service_name)
}
inline ::std::string* SubServiceAddressRsp::mutable_service_name() {
  
  // @@protoc_insertion_point(field_mutable:eco.service.proto.SubServiceAddressRsp.service_name)
  return service_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubServiceAddressRsp::release_service_name() {
  // @@protoc_insertion_point(field_release:eco.service.proto.SubServiceAddressRsp.service_name)
  
  return service_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubServiceAddressRsp::set_allocated_service_name(::std::string* service_name) {
  if (service_name != NULL) {
    
  } else {
    
  }
  service_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service_name);
  // @@protoc_insertion_point(field_set_allocated:eco.service.proto.SubServiceAddressRsp.service_name)
}

// -------------------------------------------------------------------

// PubServiceAddressReq

// string service_name = 10;
inline void PubServiceAddressReq::clear_service_name() {
  service_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PubServiceAddressReq::service_name() const {
  // @@protoc_insertion_point(field_get:eco.service.proto.PubServiceAddressReq.service_name)
  return service_name_.GetNoArena();
}
inline void PubServiceAddressReq::set_service_name(const ::std::string& value) {
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eco.service.proto.PubServiceAddressReq.service_name)
}
#if LANG_CXX11
inline void PubServiceAddressReq::set_service_name(::std::string&& value) {
  
  service_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eco.service.proto.PubServiceAddressReq.service_name)
}
#endif
inline void PubServiceAddressReq::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eco.service.proto.PubServiceAddressReq.service_name)
}
inline void PubServiceAddressReq::set_service_name(const char* value, size_t size) {
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eco.service.proto.PubServiceAddressReq.service_name)
}
inline ::std::string* PubServiceAddressReq::mutable_service_name() {
  
  // @@protoc_insertion_point(field_mutable:eco.service.proto.PubServiceAddressReq.service_name)
  return service_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PubServiceAddressReq::release_service_name() {
  // @@protoc_insertion_point(field_release:eco.service.proto.PubServiceAddressReq.service_name)
  
  return service_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PubServiceAddressReq::set_allocated_service_name(::std::string* service_name) {
  if (service_name != NULL) {
    
  } else {
    
  }
  service_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service_name);
  // @@protoc_insertion_point(field_set_allocated:eco.service.proto.PubServiceAddressReq.service_name)
}

// -------------------------------------------------------------------

// PubServiceAddressRsp

// .eco.service.proto.Error error = 2;
inline bool PubServiceAddressRsp::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline const ::eco::service::proto::Error& PubServiceAddressRsp::error() const {
  const ::eco::service::proto::Error* p = error_;
  // @@protoc_insertion_point(field_get:eco.service.proto.PubServiceAddressRsp.error)
  return p != NULL ? *p : *reinterpret_cast<const ::eco::service::proto::Error*>(
      &::eco::service::proto::_Error_default_instance_);
}
inline ::eco::service::proto::Error* PubServiceAddressRsp::release_error() {
  // @@protoc_insertion_point(field_release:eco.service.proto.PubServiceAddressRsp.error)
  
  ::eco::service::proto::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::eco::service::proto::Error* PubServiceAddressRsp::mutable_error() {
  
  if (error_ == NULL) {
    error_ = new ::eco::service::proto::Error;
  }
  // @@protoc_insertion_point(field_mutable:eco.service.proto.PubServiceAddressRsp.error)
  return error_;
}
inline void PubServiceAddressRsp::set_allocated_error(::eco::service::proto::Error* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:eco.service.proto.PubServiceAddressRsp.error)
}

// string service_name = 10;
inline void PubServiceAddressRsp::clear_service_name() {
  service_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PubServiceAddressRsp::service_name() const {
  // @@protoc_insertion_point(field_get:eco.service.proto.PubServiceAddressRsp.service_name)
  return service_name_.GetNoArena();
}
inline void PubServiceAddressRsp::set_service_name(const ::std::string& value) {
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eco.service.proto.PubServiceAddressRsp.service_name)
}
#if LANG_CXX11
inline void PubServiceAddressRsp::set_service_name(::std::string&& value) {
  
  service_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eco.service.proto.PubServiceAddressRsp.service_name)
}
#endif
inline void PubServiceAddressRsp::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eco.service.proto.PubServiceAddressRsp.service_name)
}
inline void PubServiceAddressRsp::set_service_name(const char* value, size_t size) {
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eco.service.proto.PubServiceAddressRsp.service_name)
}
inline ::std::string* PubServiceAddressRsp::mutable_service_name() {
  
  // @@protoc_insertion_point(field_mutable:eco.service.proto.PubServiceAddressRsp.service_name)
  return service_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PubServiceAddressRsp::release_service_name() {
  // @@protoc_insertion_point(field_release:eco.service.proto.PubServiceAddressRsp.service_name)
  
  return service_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PubServiceAddressRsp::set_allocated_service_name(::std::string* service_name) {
  if (service_name != NULL) {
    
  } else {
    
  }
  service_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service_name);
  // @@protoc_insertion_point(field_set_allocated:eco.service.proto.PubServiceAddressRsp.service_name)
}

// -------------------------------------------------------------------

// OnPubServiceAddress

// string service_name = 10;
inline void OnPubServiceAddress::clear_service_name() {
  service_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OnPubServiceAddress::service_name() const {
  // @@protoc_insertion_point(field_get:eco.service.proto.OnPubServiceAddress.service_name)
  return service_name_.GetNoArena();
}
inline void OnPubServiceAddress::set_service_name(const ::std::string& value) {
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eco.service.proto.OnPubServiceAddress.service_name)
}
#if LANG_CXX11
inline void OnPubServiceAddress::set_service_name(::std::string&& value) {
  
  service_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eco.service.proto.OnPubServiceAddress.service_name)
}
#endif
inline void OnPubServiceAddress::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eco.service.proto.OnPubServiceAddress.service_name)
}
inline void OnPubServiceAddress::set_service_name(const char* value, size_t size) {
  
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eco.service.proto.OnPubServiceAddress.service_name)
}
inline ::std::string* OnPubServiceAddress::mutable_service_name() {
  
  // @@protoc_insertion_point(field_mutable:eco.service.proto.OnPubServiceAddress.service_name)
  return service_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OnPubServiceAddress::release_service_name() {
  // @@protoc_insertion_point(field_release:eco.service.proto.OnPubServiceAddress.service_name)
  
  return service_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OnPubServiceAddress::set_allocated_service_name(::std::string* service_name) {
  if (service_name != NULL) {
    
  } else {
    
  }
  service_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service_name);
  // @@protoc_insertion_point(field_set_allocated:eco.service.proto.OnPubServiceAddress.service_name)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace service
}  // namespace eco

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Service_2eproto__INCLUDED
